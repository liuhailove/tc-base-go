// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package tc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EgressClient is the client API for Egress service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EgressClient interface {
	// start recording or streaming a room, participant, or tracks
	StartRoomCompositeEgress(ctx context.Context, in *RoomCompositeEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	StartWebEgress(ctx context.Context, in *WebEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	StartParticipantEgress(ctx context.Context, in *ParticipantEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	StartTrackCompositeEgress(ctx context.Context, in *TrackCompositeEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	StartTrackEgress(ctx context.Context, in *TrackEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	// update web composite layout
	UpdateLayout(ctx context.Context, in *UpdateLayoutRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	// add or remove stream endpoints
	UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*EgressInfo, error)
	// list available egress
	ListEgress(ctx context.Context, in *ListEgressRequest, opts ...grpc.CallOption) (*ListEgressResponse, error)
	// stop a recording or stream
	StopEgress(ctx context.Context, in *StopEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error)
}

type egressClient struct {
	cc grpc.ClientConnInterface
}

func NewEgressClient(cc grpc.ClientConnInterface) EgressClient {
	return &egressClient{cc}
}

func (c *egressClient) StartRoomCompositeEgress(ctx context.Context, in *RoomCompositeEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/StartRoomCompositeEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) StartWebEgress(ctx context.Context, in *WebEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/StartWebEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) StartParticipantEgress(ctx context.Context, in *ParticipantEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/StartParticipantEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) StartTrackCompositeEgress(ctx context.Context, in *TrackCompositeEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/StartTrackCompositeEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) StartTrackEgress(ctx context.Context, in *TrackEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/StartTrackEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) UpdateLayout(ctx context.Context, in *UpdateLayoutRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/UpdateLayout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) UpdateStream(ctx context.Context, in *UpdateStreamRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/UpdateStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) ListEgress(ctx context.Context, in *ListEgressRequest, opts ...grpc.CallOption) (*ListEgressResponse, error) {
	out := new(ListEgressResponse)
	err := c.cc.Invoke(ctx, "/tc.Egress/ListEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *egressClient) StopEgress(ctx context.Context, in *StopEgressRequest, opts ...grpc.CallOption) (*EgressInfo, error) {
	out := new(EgressInfo)
	err := c.cc.Invoke(ctx, "/tc.Egress/StopEgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EgressServer is the server API for Egress service.
// All implementations must embed UnimplementedEgressServer
// for forward compatibility
type EgressServer interface {
	// start recording or streaming a room, participant, or tracks
	StartRoomCompositeEgress(context.Context, *RoomCompositeEgressRequest) (*EgressInfo, error)
	StartWebEgress(context.Context, *WebEgressRequest) (*EgressInfo, error)
	StartParticipantEgress(context.Context, *ParticipantEgressRequest) (*EgressInfo, error)
	StartTrackCompositeEgress(context.Context, *TrackCompositeEgressRequest) (*EgressInfo, error)
	StartTrackEgress(context.Context, *TrackEgressRequest) (*EgressInfo, error)
	// update web composite layout
	UpdateLayout(context.Context, *UpdateLayoutRequest) (*EgressInfo, error)
	// add or remove stream endpoints
	UpdateStream(context.Context, *UpdateStreamRequest) (*EgressInfo, error)
	// list available egress
	ListEgress(context.Context, *ListEgressRequest) (*ListEgressResponse, error)
	// stop a recording or stream
	StopEgress(context.Context, *StopEgressRequest) (*EgressInfo, error)
	mustEmbedUnimplementedEgressServer()
}

// UnimplementedEgressServer must be embedded to have forward compatible implementations.
type UnimplementedEgressServer struct {
}

func (UnimplementedEgressServer) StartRoomCompositeEgress(context.Context, *RoomCompositeEgressRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRoomCompositeEgress not implemented")
}
func (UnimplementedEgressServer) StartWebEgress(context.Context, *WebEgressRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWebEgress not implemented")
}
func (UnimplementedEgressServer) StartParticipantEgress(context.Context, *ParticipantEgressRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartParticipantEgress not implemented")
}
func (UnimplementedEgressServer) StartTrackCompositeEgress(context.Context, *TrackCompositeEgressRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTrackCompositeEgress not implemented")
}
func (UnimplementedEgressServer) StartTrackEgress(context.Context, *TrackEgressRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTrackEgress not implemented")
}
func (UnimplementedEgressServer) UpdateLayout(context.Context, *UpdateLayoutRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLayout not implemented")
}
func (UnimplementedEgressServer) UpdateStream(context.Context, *UpdateStreamRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStream not implemented")
}
func (UnimplementedEgressServer) ListEgress(context.Context, *ListEgressRequest) (*ListEgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEgress not implemented")
}
func (UnimplementedEgressServer) StopEgress(context.Context, *StopEgressRequest) (*EgressInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopEgress not implemented")
}
func (UnimplementedEgressServer) mustEmbedUnimplementedEgressServer() {}

// UnsafeEgressServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EgressServer will
// result in compilation errors.
type UnsafeEgressServer interface {
	mustEmbedUnimplementedEgressServer()
}

func RegisterEgressServer(s grpc.ServiceRegistrar, srv EgressServer) {
	s.RegisterService(&Egress_ServiceDesc, srv)
}

func _Egress_StartRoomCompositeEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomCompositeEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).StartRoomCompositeEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/StartRoomCompositeEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).StartRoomCompositeEgress(ctx, req.(*RoomCompositeEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_StartWebEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WebEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).StartWebEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/StartWebEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).StartWebEgress(ctx, req.(*WebEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_StartParticipantEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).StartParticipantEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/StartParticipantEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).StartParticipantEgress(ctx, req.(*ParticipantEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_StartTrackCompositeEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackCompositeEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).StartTrackCompositeEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/StartTrackCompositeEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).StartTrackCompositeEgress(ctx, req.(*TrackCompositeEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_StartTrackEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrackEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).StartTrackEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/StartTrackEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).StartTrackEgress(ctx, req.(*TrackEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_UpdateLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).UpdateLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/UpdateLayout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).UpdateLayout(ctx, req.(*UpdateLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_UpdateStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).UpdateStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/UpdateStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).UpdateStream(ctx, req.(*UpdateStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_ListEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).ListEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/ListEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).ListEgress(ctx, req.(*ListEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Egress_StopEgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopEgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EgressServer).StopEgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tc.Egress/StopEgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EgressServer).StopEgress(ctx, req.(*StopEgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Egress_ServiceDesc is the grpc.ServiceDesc for Egress service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Egress_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tc.Egress",
	HandlerType: (*EgressServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartRoomCompositeEgress",
			Handler:    _Egress_StartRoomCompositeEgress_Handler,
		},
		{
			MethodName: "StartWebEgress",
			Handler:    _Egress_StartWebEgress_Handler,
		},
		{
			MethodName: "StartParticipantEgress",
			Handler:    _Egress_StartParticipantEgress_Handler,
		},
		{
			MethodName: "StartTrackCompositeEgress",
			Handler:    _Egress_StartTrackCompositeEgress_Handler,
		},
		{
			MethodName: "StartTrackEgress",
			Handler:    _Egress_StartTrackEgress_Handler,
		},
		{
			MethodName: "UpdateLayout",
			Handler:    _Egress_UpdateLayout_Handler,
		},
		{
			MethodName: "UpdateStream",
			Handler:    _Egress_UpdateStream_Handler,
		},
		{
			MethodName: "ListEgress",
			Handler:    _Egress_ListEgress_Handler,
		},
		{
			MethodName: "StopEgress",
			Handler:    _Egress_StopEgress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tc_egress.proto",
}
